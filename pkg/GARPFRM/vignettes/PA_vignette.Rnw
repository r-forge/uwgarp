\documentclass[a4paper]{article}
\usepackage[OT1]{fontenc}
\usepackage{Sweave}
\usepackage{Rd}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{url}
\usepackage[round]{natbib}
\usepackage{bm}
\usepackage{verbatim}
\usepackage[latin1]{inputenc}
\bibliographystyle{abbrvnat}

\let\proglang=\textsf
%\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
%\newcommand{\R}[1]{{\fontseries{b}\selectfont #1}}
%\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%\newcommand{\E}{\mathsf{E}}
%\newcommand{\VAR}{\mathsf{VAR}}
%\newcommand{\COV}{\mathsf{COV}}
%\newcommand{\Prob}{\mathsf{P}}

\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\baselinestretch}{1.5}
\setlength{\textwidth}{15cm} \setlength{\textheight}{22cm} \topmargin-1cm \evensidemargin0.5cm \oddsidemargin0.5cm

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{lmodern}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Performance Analysis Measures}
\author{Mark L Labovitz}

\maketitle

\begin{abstract}
Applying The CAPM to Performance Measurement Using Quandl data


Uses computations as interpreted from Chapter 7 of 2013 FRM Level I Manual.

Computational Focus:\\
1. Treynor Ratio;\\
2. Sharpe Ratio;\\
3. Jensen's Alpha;\\
4. Tracking Error;\\
5. Information Ratio;\\
6. Sortino Ratio.


Ancillary computation (necessary but not focus of Chapter):\\
1. Beta;\\
2. Downside Deviation.


Assumptions:\\
1. Computations use the PerformanceAnalytics Library.\\
2. There are alternative means of computing the measure which relate to such elements as:\\
   a. The use of as recorded or excess returns;\\
   b. The method annualization: arithmetic or geometric;\\
   c. The order of return adjustment and averaging;\\ 
   
Relevant Abbreviations:\\
IP == Investment Portfolio;\\
MP == Market/Benchmark Portfolio;\\
RF == Risk Free Rate;\\
sp == Sub Period (the period of the data, e.g. day, week, month).

\end{abstract}

\tableofcontents

\section{Setting Up The Analysis}
\subsection{Establishing RunTime Parameters}
<<ex1>>=
# Store results
Measures = rep(NULL,4)

# If equalWts is true portfolio weights will be 1/numberOfSecurities
equalWts = TRUE

randWts = TRUE
if(equalWts) randWts = FALSE

# Number of securities to use is 
numberOfSecurities = 3

# Security Selection Method, "randomSeq" or "serialSeq"
secSel = "serialSeq"

# type of chaining in forming the aggregate return
# If geometric is TRUE use geometric chaining if False use arithemetic chaining
geometricB = TRUE

# Definitioned/Constant variables
relation = c("Less Than","Equal To","Greater Than")

# Some of run time parameters
# Should be amongst the input for shiny
# Minimum Acceptable Return for Sortino Ratio or Downside Deviation
# defaults to 0
MAR_set = 0

# Denominator for Sortino Ratio or Downside Deviation 
# one of "full" or "subset", indicating whether to use the length of the full series
# or the length of the subset of the series below the MAR as the denominator,
# defaults to "full"
denom = "full"

# Portfolio name used in output
PortName = "Portfolio"

# Market name used in output
MrktName ="Market"

#Market Name in data set
mrktDataName = "market"

# Risk free rate name used in output
RFName="Risk_Free_Rate"

# Risk Free Name in data set
rfDataName = "t90"

# Number time periods for year for data set
freQ = 12

# Names of Measures column
Measures = rbind(Measures, c("Series Name",PortName,MrktName,RFName))
colnames(Measures) = c("Measure","Portfolio","Market","RiskFree")
@
\subsection{Echo Parameters}
Echo print run-time parameters
<<ex1a>>=
cat('\n Random Weights: ',randWts,'\n')
cat('\n Number of securities in portfolio = ',numberOfSecurities,'\n')
cat('\n Security selection method: ',secSel,'\n')
cat('\n Geometric annualization (false means arithmetic): ',geometricB,'\n')
cat('\n Minimum Acceptable Return for Sortino Ratio or Downside Deviation: ',MAR_set,'\n')
cat('\n Denominator for downside deviation (Full count or Subset < MAR_set): ',denom,'\n')
namesUsed = c(PortName,MrktName,RFName)
names(namesUsed) = c("Portfolio_Name","Market/BenchMark_Name","RiskFreeRate_name")
cat("\n Names of Portfolio, Market and RiskFree Series used in output")
print(namesUsed)

cat('\n Number of data units in a year: ',freQ,'\n')


@
\subsection{Extracting and Organizing Data}
<<ex2>>=
# 'Load the GARPFRM package and the CAPM dataset.
suppressMessages(library(GARPFRM))
options(digits=5)
data(crsp.short)

# Make the assumption that the last two time series are the Market and RF series
# Tickers/Names of time series in the test data set
cat('\n List column headers predominantly tickers/name of securities')
colnames(largecap.ts)
@
Summarize the first and last data values corresponding to the first 5 dates for the first 5 returns, followed by number of periods in time series
<<ex3>>=
head(largecap.ts)
tail(largecap.ts)
nRow = nrow(largecap.ts)
nRow

@
\subsection{Extract Market (Benchmark) And Risk Free Series}
Determine pointer to column with the market returns and pointer to column of Risk Free Ratw
<<ex4>>=

ptrMkt = which(colnames(largecap.ts)==mrktDataName,arr.ind=TRUE)
ptrMkt

ptrRF = which(colnames(largecap.ts)==rfDataName,arr.ind=TRUE)
ptrRF

# Market returns
R.market <- largecap.ts[, ptrMkt]

# risk free rate
rf <- largecap.ts[, ptrRF]
## 
@

\subsection{Generate Portforlio For Further Analysis}
Generate Portfolio weights based upon selected method and create portfolio.
<<ex5>>=
# Number of time series in data set
nSec = ncol(largecap.ts)

if (numberOfSecurities>(nSec-2)) numberOfSecurities = nSec - 2
cat('\n Number of Securities being used in portfolio = ',numberOfSecurities, '\n')

# Security position numbers of securities in portfolio
secNbrs = seq(1,numberOfSecurities)
if(secSel=="randomSeq") secNbrs = sample.int(nSec, size = numberOfSecurities, replace = FALSE)

cat('\n Selected Security position indicies')
print(secNbrs)

#
# Created random wts from the non-market non RF series if selected
if (randWts){
  coefs = runif(numberOfSecurities)
  alphas = coefs/sum(coefs)
  sum(alphas)
}  

# Generate portfolio from selected securities and associated weigts
if (equalWts) {
  R.portfolio <- Return.portfolio(largecap.ts[, secNbrs],geometric=geometricB)  
} else {
  R.portfolio = Return.portfolio(largecap.ts[, secNbrs],weights=alphas,geometric=geometricB) 
}

# Print names of securities in portfolio
cat('\n Securities in Portfolio')
print(colnames(largecap.ts)[secNbrs])

colnames(R.portfolio) ="PortRets"

# Compute initial ancillary statistics and set them in the summary matrix
salient = matrix(data=c("Mean",mean(R.portfolio),mean(R.market),mean(rf),
                   "Stdev",sd(R.portfolio),sd(R.market),sd(rf),
                   "NbrSecuritiesInPort",numberOfSecurities,"","",
                   "AnnuallyFrequency",rep(freQ,3),
                   "Number of Samples",rep(nRow,3)),ncol=4,byrow=TRUE)

Measures = rbind(Measures, salient)

# Results used later in computation
# Mean of risk free rate over sampling time series
meanRF = mean(rf)

# Precompute excess returns
xCessP1 = R.portfolio - rf
xCessM1 = R.market - rf

# Precompute relative return [RR] = (Investment Portfolio [IP] - Market Portfolio [MP]) 
# and average relative return [ARR] = mean(RR)
  
RR = R.portfolio-R.market
ARR = mean(RR)

@
\section{Treynor Ratio}
(Add more commentary) Where TR denotes the Treynor Ratio and IP and MP denote the Investment Portfolio and Market Portfolio 
\subsection{Beta}
Compute Beta using excess returns.
<<ex6>>=

# Compute Beta from excess returns.
betaRF = cov((R.portfolio[,1]-rf),(R.market-rf))/var((R.market-rf))

# Output value of Beta
cat('\n Beta =',betaRF,', between the excess portfolio represented by ',PortName,' and the excess market represented by ',MrktName,' \n')

Measures = rbind(Measures,c("Beta",betaRF,"",""))
@
\subsection{Treynor Ratio}
Compute the Traynor Ratio.
<<ex7>>=

# Treynor ratio for portfolio and market
# Recall that Beta for the market is 1
tr = TreynorRatio(R.portfolio, R.market,rf,freQ )
trMarket = TreynorRatio(R.market,R.market,rf,freQ )

# Output salient results from Treynor Ratio computation
cat('\n PA computed for ',PortName,' Treynor Ratio = ',tr,'\n')
cat('\n PA computed for ',MrktName,' Treynor Ratio = ',trMarket,'\n')

Measures = rbind(Measures,c("Treynor Ratio",tr,trMarket,""))
@
As per the Chapter comparing the Treynor Ratio for the investment portfolio versus the Treynor Ratio for the market portfolio allows a check on whether or not the investment portfolio is being sufficiently rewarded for its level of risk, i.e. the TR(IP) greater than or equal TR(MP).
<<ex8>>=

# Compare Treynor Ratio for market returns against Treynor Ratio for portfolio returns
TR_Mrkt2Port = relation[sign(trMarket - tr) + 2]
cat('\n Treynor Ratio of ',MrktName,' is ',TR_Mrkt2Port,' Treynor Ratio of ',PortName,'\n' )
@
\section{Sharpe Ratio}
Developed by Nobel Laureate William F. Sharpe, the Sharpe ratio is a risk-adjusted measure of performance, also known as the reward-to-volatility or reward per unit of risk ratio.   It is calculated as the average sp excess return divided by the standard deviation of sp excess returns over a period of interest. The excess return is the difference between the IP return and the RF return for an sp. A higher Sharpe ratio means better fund performance relative to the risk-free rate on a risk-adjusted basis.
<<ex9>>=

# Compute Sharpe and annualized Sharpe Ratio
shr = SharpeRatio(R.portfolio, rf, FUN = "StdDev")
shrAnn = SharpeRatio.annualized(R.portfolio, rf, scale=freQ, geometric=TRUE)

# Output salient results for Sharpe Ratio
cat('\n PA computed ',PortName,' Sharpe Ratio = ',shr,'\n')
cat('\n PA computed ',PortName,' Annualized Sharpe Ratio = ',shrAnn,'\n')

Measures = rbind(Measures,matrix(c("Sharpe Ratio",shr,"","","Sharpe Ratio Annualized",shrAnn,"",""),ncol=4,byrow=TRUE))
@
\section{Jensen's Alpha}
(Add more commentary)
<<ex10>>=
# Compute Jensen's Alpha

# Produces one value
jaStatic = CAPM.jensenAlpha(R.portfolio,R.market,meanRF)

# Produces multiple values
jaTV = CAPM.jensenAlpha(R.portfolio, R.market,rf)

# Regression computation and salient results
lm_ja1.fit = lm(xCessP1 ~ xCessM1)
values1 = summary(lm_ja1.fit)
values1
analT1 = values1[[4]]

# Annualize Jensen's Alpha
jaHandA = (1+(mean(R.portfolio) - meanRF - betaRF*(mean(R.market)-meanRF)))^freQ -1

# Use Delta Method to approximate standard error of annualized Jensen's Alpha
deltaCoef = (freQ*(1+analT1[1,1])^(freQ-1))^2

# Output salient results for Jensen's Alpha
cat('\n PA computed ',PortName,' Static Jensen\'s Alpha = ',jaStatic,'\n')
cat('\n Hand computed Annualized ',PortName,' Jensen Alpha = ',jaHandA,'\n')
cat('\n Delta Method Coefficient Value = ', deltaCoef,'\n')

# t stat and pvalue under H0: alpha = 0 against HA: alpha != 0 
tStat = jaHandA/(analT1[1,2]*deltaCoef^0.5)
pValue = 2*(1-pt(tStat,nRow-2))
cat('\n H0: alpha = 0, HA: alpha != 0  p-value: ',pValue,'\n')

Measures = rbind(Measures,matrix(c("Jensen's Alpha",jaStatic,"","","Jensen's Alpha Annualized",jaHandA,"","",
                                   "Jensen's Alpha P Value",pValue,"",""),ncol=4,byrow=TRUE))

@
\section{Tracking Error}
(Add more commentary)
<<ex11>>=

# Compute Tracking Error

te = TrackingError(R.portfolio, R.market, scale = freQ)

# Output salient results from Tracking Error computation
cat('\n PA computed ',PortName,' Tracking Error = ',te,'\n')

Measures = rbind(Measures,c("Tracking Error",te,"",""))
@
\section{Information Ratio}
(Add more commentary)
<<ex12>>=

# Crompute Information Ratio
# Definition PA, InformationRatio = ActivePremium/TrackingError
#Active Premium = Investment's annualized return - Benchmark's annualized return
ir = InformationRatio(R.portfolio, R.market, scale = freQ)

# Output salient results from Information Ratio computation  
cat('\n PA computed ',PortName,' Information Ratio = ',ir,'\n')

Measures = rbind(Measures,c("Information Ratio",ir,"",""))
@
\section{Downside Deviation and Sortino Ratio}
(Add more commentary)
\subsection{Downside Deviation}
Downside Deviation is a measure of risk which just captures the downside or returns below a minimal acceptible return or MAR. Consequently the computation only includes as non-zero those returns less than the MAR. MAR in the present case is set as single value, in other calculations it itself is a series, often the  market/benchmark performance. As downside deviation increases it means higher risk on the downside relative to the MAR. Beyond the MAR, an important parametric consideration is the decision to normalize the deviations by the total number of values in the time series or just the number of deviations which are not equal to zero (in either case the denominator count is maybe reduced by 1)
<<ex13>>=

# Compute Downside Deviation

# Set value of denominator for Downside Deviation from the parameter set earlier
denomVal = nRow
if (denom != "full")
   { 
    denomVal = sum(ifelse((R.portfolio - MAR_set)<0,1,0))
   }
cat('\n Denominator parameter is set to: ',denom,' which results in a denominator value of ',denomVal,'\n')

cat('\n MAR == Minimal Acceptable Return, number of MAR values = ',length(MAR_set))
head(as.vector(MAR_set))
if(length(MAR_set)>5) tail(as.vector(MAR_set))

# PA computation of Downside Deviation
dwn = DownsideDeviation(R.portfolio, MAR = MAR_set, method = denom)

# Output salient computation of Downside Deviation
cat('\n PA computed ',PortName,'  Downside Deviation = ',dwn,'\n')

Measures = rbind(Measures,c("Downside Deviation",dwn,"",""))
Measures = rbind(Measures,c("Denominator DD",denomVal,"",""))
@
\subsection{Sortino Ratio}
(Add more commentary)
<<ex14>>=

# Compute Sortino Ratio 
sr = SortinoRatio(R.portfolio, MAR = MAR_set, weights = NULL)

# Output salient computations of Sortino Ratio
cat('\n PA computed ',PortName,'  Sortino Ratio = ',sr,'\n')

Measures = rbind(Measures,c("Sortino Ratio",sr,"",""))
@
\section{Summary of Performance Measures}
Summary of values and statistics computed from input IP, MP and risk free rate series. 
<<ex15>>=

Measures.few = cbind(Measures[,1],substr(Measures[,2:4],1,8))
Measures.few = rbind(Measures[1,],Measures.few[-1,])

Measures.df= as.data.frame(Measures.few,stringsAsFactors=FALSE)
print(Measures.df)
@


\end{document}